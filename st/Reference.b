// Copyright ©2015 Black Sphere Studios
// For conditions of distribution and use, see copyright notice in LICENSE.txt

namespace Berry {  
  // Represents a unique reference to memory that is destroyed or moved when appropriate.
  /*template[T]
  class NullableRef
  {    
    NullableRef(unsafe T@ p) : _p(p){}
    NullableRef(NullableRef!! mov) : _p(mov._p) { mov._p = null; }
    ~NullableRef() { if(_p) _p.~T(); }
    NullableRef op=(NullableRef!! r) { _p.~T(); _p = mov._p; mov._p = null; }
    //static T op(NullableRef r) { return $r._p; } // These have to be generated by the compiler or things get really confusing
    //static NullableRef op(T v) { return NullableRef(@v);}
      
  protected: 
    unsafe T@ _p;
  }
  
  // Represents a unique reference to memory that is always destroyed and can never be moved or not be null.
  template[T]
  class NonNullableRef
  {
    NonNullableRef(unsafe T@ p) : _p(p) { assert(_p != null); }
    NonNullableRef(NonNullableRef!!) = delete;
    ~NonNullableRef() { _p.~T(); }
    
  protected: 
    unsafe T@ _p;
  }
  
  template[T]
  trait Reference_T : pointer
  {
    T@$ op@();
    T op$() const;
  }
  
  template[T]
  trait NonNullReference_T : Reference_T[T]
  {
    T$$ op@();
  }
  
  template[T]
  impl NullableRef : Reference_T[T]
  {
    T@$ op@() { return NonNullableRef[T@](@_p); }
    T op$() const { return $_p; }
  }
  
  template[T]
  impl NonNullableRef : NonNullReference_T[T]
  {
    T@$ op@() { return NonNullableRef[T@](@_p); }
    T$$ op@() { return NonNullableRef[T$](@_p); }
    T op$() const { return $_p; }
  }*/
}